## 索引

分类

- primary key

  主键，一个表只能有一个，值不能重复也不能为null

- unique

  唯一索引，索引列的值不能重复，但可以为null

- 普通索引

- fulltext 

  全文索引，主要用来查找文本中的关键字，更像是一个搜索引擎

还可以分为

- 单值索引

  一个索引只有一列，一个表可以有多个单值索引

- 复合索引

  一个索引有多列

复合索引比单值索引更常用，因为复合索引支持高并发

### 索引的使用

```sql
-- 创建索引，在user表上创建id单值索引和id,name复合索引
create unique index idx_user_id on user(id);

create index idx_user_idName on user(id,name);

-- 也可在建表时创建
CREATE TABLE user(
    			  ID INT NOT NULL,
    			  name VARCHAR(16) NOT NULL, 
    			  INDEX idx_user_idName (id,name));
    			  

-- 添加索引
alter table user add index idx_user_name(name);

alter table user add primary key(id)；

-- 删除索引
drop unique index idx_user_id on user;

-- 查看索引，包括主键
show index from user;

show index from user \G
```

### 索引理解

索引本质是**排好序**的快速**查找**的数据结构，本身很大，以索引文件的形式存储在磁盘上。MySQL会另外维护一个查找算法的数据结构来支持索引，一般都为B树/B+树。以B+树为例，假设索引是从1排到20，现在查找索引为15的记录。从顶部开始查找，发现15在11到17之间；由p2指针查找，发现15大于14，从14处的p2继续查找；到达叶子节点，由14查到了15（这里只是指针）

![](https://github.com/f-zhuo/MySQL/raw/master/pictures/Btree.png)

但是，在一些细节方面，不同引擎的索引实现有所不同：

* MyISAM：叶子节点的data域存储的是数据记录的物理地址，会先找到索引的值，再由索引的值去找物理地址，找到数据记录。索引文件和数据文件是分开的，索引文件只是存储数据记录的地址
* InnoDB：叶子节点的data域存储的是数据记录本身，找到索引就直接找到了数据记录。数据文件就是索引文件

**索引优势**

- 提高数据库快速检索的能力，降低了IO成本
- 索引排好序降低了排序成本，降低了CPU消耗

**索引劣势**

- 索引本身也是文件，要占用大量空间
- 当数据更新时，不仅数据要更新，索引也要更新，更新效率变慢
- 一套优秀的索引系统要经过很多次优化，占用时间

**需要建索引的情况**

- 主键自动建立唯一索引
- 频繁使用的字段需要建索引
- 排序字段可以建索引
- 多表连接，需要外键索引

**不需要建索引的情况**

- 频繁更新的字段不需要索引

- where没使用的字段不需要索引

- 记录太少的表不需要索引

- 重复值太多/索引选择性太低的字段不需要索引，比如性别

  *索引的选择性：字段未重复的记录数/字段总记录数*

### 索引优化

MySQL查询性能下降原因

- SQL语句写的不好
- 索引失效，设置了索引但没用上
- 太多join，子查询
- 调优参数设置问题

#### explain

模拟MySQL优化器执行SQL语句的过程，方法是explain+SQL语句

explain的结果（例）

|  id  | select_type |   table    | type  | possible keys |     key      | key_len | ref  | rows | Extra |
| :--: | :---------: | :--------: | :---: | :-----------: | :----------: | :-----: | :--: | :--: | :---: |
|  2   |   simple    |     A      |  ref  | idx_col1col2  | idx_col1col2 |    5    | col1 |  56  |       |
|  1   |   primary   |     B      | range |   idx_col3    |     null     |  null   | col3 | 100  |       |
|  1   |   derived   | derived(2) | const |     null      | idx_col1col2 |    6    | col2 |  1   |       |

explain可以做的事

- 查看表的读取顺序，引用关系

id表示读取表的顺序，有三种情况

|    id    |                           含义                            |
| :------: | :-------------------------------------------------------: |
|  全相同  |             按照table的内容，自上而下顺序读取             |
|  全不同  |              先读取id大的表，id小的最后读取               |
| 不全相同 | 先读取id大的表，对于id相同的表，按照table自上而下顺序执行 |

derived(2)表示该表是从id为2的表读取出来的

- 读取数据的操作类型

由select_type说明，分为6种

| select_type  |             含义             |
| :----------: | :--------------------------: |
|    simple    |     不包含子查询和union      |
|   primary    | 子查询中最外层的查询，主查询 |
|   subquery   |            子查询            |
|   derived    | 衍生查询，包含在from里的查询 |
|    union     |                              |
| union result |         union的结果          |

- 查询类型（type）

由好到坏：system>const>eq_ref>ref>range>index>all

|  type  |                       含义                        |
| :----: | :-----------------------------------------------: |
| system |                 表中只有一行记录                  |
| const  |            有确定的索引，一次就查询到             |
| eq_ref |       唯一性索引，每一个索引都只有一条记录        |
|  ref   |  非唯一性索引，每一个索引都返回对应的所有的记录   |
| range  | 只检索一定范围的行，一般出现在between，in，>，<等 |
| index  |               全索引扫描，遍历索引                |
|  all   |                     全表扫描                      |

- 查看是否利用索引

possible key是可能用到的索引，key是实际用到的索引，null表示没用索引或者索引失效

- 查看使用的索引字节数

key_len是索引字段的最大可能长度，不是实际长度，索引越多，key_len越大，查找精度相同时，该值越小越好

- 查看使用了索引的哪些列

ref表示，如果是const，那就是查询使用的索引是一个常数；一般格式是database.table.column

- 查看有多少行被优化器查询

rows表示，估算要读取的行数，越小越好

- 其他信息

不适合放在其他列但也很重要，extra表示

|       extra       |                             含义                             |
| :---------------: | :----------------------------------------------------------: |
|  using filesort   | 文件内排序，实际使用的复合索引的列的个数或顺序和复合索引不一致。比如索引idx_A_abc，实际使用的索引列是a和c |
|  using temporary  |               临时表，多见于order by和group by               |
|    using index    | 表明效率不错，若同时存在using where，表明索引被用于查找；若不存在，表明索引只是用来读取数据 |
| using join buffer |                             缓存                             |
| impossible where  |                 where连接条件不可能同时存在                  |

*覆盖索引：查询的字段都包含在索引列（包括primary key）里*

**join连接时的索引优化**

left join时索引建在右表，right join时索引建在左表，尽量使用覆盖索引，不用select *

#### 索引失效原因

- 全值匹配(=)时违反了最佳左前缀原则

*最佳左前缀原则：使用复合索引查找时，必须按照建立索引的列的顺序，从最左边的索引列开始，不能跳过中间列，可以是索引列的子列*

- 在索引列的任何操作（计算，函数，类型转换）

- 复合索引的中间某列explain的type为range(>,<,between and)，后面的索引列都失效

- !=，<>，is null都会使索引失效

- 使用通配符和like查找时，explain的type是range，解决方法是使用覆盖索引，形如`like '%a'`和`like '%a%'`都会使索引失效，但形如`like 'a%'/'a%aa%'`索引不会失效

## show profile

可以显示所有执行的SQL语句的执行时间

```sql
-- 显示query_id这条SQL语句在整个执行子过程的执行时间，CPU消耗等
show profile cpu,block io for query `query_id`
```

## 查询优化

步骤

- 在慢查询日志里找到慢查询SQL
- explain执行
- show profile查看执行细节
- SQL参数调优

慢查询日志：记录执行时间超过阈值的SQL语句的日志

*两表连接时，小表驱动大表来优化查询*

in与exists比较

```sql
-- B表小于A表
select * from A where id in (select id from B );
-- A表小于B表，exists返回的是布尔值，子查询中select *会被忽略，可以写select 1/任意值
select * from A where exists (select * from B where A.id=B.id );
```

### 索引在order by的应用

order by用到了索引的排序，没用到检索功能

order by 排序有两种：index和filesort。filesort有两种排序：单路排序和双路排序

- 双路排序

  扫描两次磁盘

- 单路排序

  扫描一次磁盘，在buffer中进行排序，按排序结果输出，避免二次扫描。但在buffer中排序需要更多空间，如果buffer空间不足，不能够一次取出所有数据就会多次单路排序，反而更耗时

*多列进行order by 时，同为asc或者desc会使用index，否则用filesort*

*group by会先排序*

