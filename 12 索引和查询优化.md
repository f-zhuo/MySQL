## 索引

分类：

* 普通索引

- unique：唯一索引，索引列的值不能重复，但可以为null

- primary key：主键，特殊的唯一索引。一个表只能有一个，值不能重复也不能为null

- fulltext ：全文索引，主要用来查找文本中的关键字，更像是一个搜索引擎，建在char，varchar，text类型的列上


还可以分为：

- 单值索引：一个索引只有一列，一个表可以有多个单值索引

- 复合索引：一个索引有多列


复合索引比单值索引更常用，因为复合索引支持高并发

### 聚集索引和二级索引

每个InnoDB表具有一个特殊的索引称为聚簇索引/clustered index （也叫聚集索引，聚类索引，簇集索引），是InnoDB存储引擎的数据组织方式。如果表上定义有主键，该主键索引就是聚簇索引。如果未定义主键，MySQL取第一个非空的唯一索引作为主键，InnoDB使用它作为聚簇索引。如果没有这样的列，InnoDB就自己产生一个这样的索引列做为聚簇索引，有6个字节，而且是隐藏的，主键值随记录数自增

聚簇索引就是一级索引，表上的其他非聚簇索引都是二级索引，又叫辅助索引（secondary index）。 二级索引的叶子节点中存储的是主键值，每次查找数据时，根据索引找到叶子节点中的主键值，根据主键值再到聚簇索引中得到完整的一行记录，这种查询方式为书签查找（bookmark lookup）。聚集索引的索引排列顺序和表记录的排列顺序一致，查找效率更快；非聚集索引的索引排列顺序和表记录顺序不一定一致，这是两者的根本区别。除此之外，聚集索引一张表只有一个，非聚集索引一张表可以有多个；聚集索引插入数据比非聚集索引慢，但查询更快

对于InnoDB而言，主键索引/聚集索引和数据存储在一起，普通索引和主键索引/聚集索引存储在一起 ；对于 MyISAM，存储的是索引数据的物理地址

*堆组织表（heap organized table/HOT）就是一般的表，数据存储是按照可用空间随机分配的，读取是按照命中率得到的。索引记录的是数据记录的行id，要根据行id找数据，数据和索引分离，是MyISAM采用的表；索引组织表（index organized table/IOT）是有索引的表，数据按索引有序存储，采用聚集索引。数据文件就是索引文件，找到了索引就找到了数据，是InnoDB采用的表；HOT存储时不考虑排序，插入数据速度快。读取/查询数据需要遍历全表，速度慢*

#### 回表

所谓回表就是在使用二级索引时，只能查找到部分数据，就需要二级索引叶子节点中的指针，也就是主键值来找到聚簇索引的所有数据，然后根据完整的数据取出所需要的列

*覆盖索引不需要回表*

### 索引的使用

```sql
-- 创建索引，在user表上创建id唯一单值索引和id,name普通复合索引
create unique index idx_user_id on user(id);

create index idx_user_idName on user(id,name);

-- 也可在建表时创建
CREATE TABLE user(
    			  ID INT NOT NULL,
    			  name VARCHAR(16) NOT NULL, 
    			  INDEX idx_user_idName (id,name));
    			  

-- 添加索引
alter table user add index idx_user_name(name);

alter table user add primary key(id)；

-- 删除索引
drop unique index idx_user_id on user;

-- 查看索引，包括主键
show index from user;

show index from user \G
```

### 索引理解

索引本质是**排好序**的快速**查找**的数据结构，本身很大，以索引文件的形式存储在磁盘上。MySQL会另外维护一个查找算法的数据结构来支持索引，一般都为B/B+树。以B+树为例，假设索引是从1排到25，现在查找索引为15的记录。从顶部开始查找，发现15在11到21之间；由11处的指针查找，发现15大于14，从14处的指针继续查找；到达叶子节点，由14查到了15

![](.\pictures\B+树.png)

但是，在一些细节方面，不同引擎的索引实现有所不同：

* MyISAM：叶子节点的data域存储的是数据记录的物理地址，会先找到索引的值，再由索引的值去找物理地址，找到数据记录。索引文件和数据文件是分开的，索引文件只是存储数据记录的地址
* InnoDB：叶子节点的data域存储的是数据记录本身，找到索引就直接找到了数据记录。数据文件就是索引文件

**使用B+树索引而不是hash索引：**

hash索引（hash值命中索引）使用hash结构，检索效率更高；B+树需要从根节点找到叶子节点。但都使用B+树而不是hash索引

* 不同的索引值可以有同一个hash值，由hash值得到索引后还需要回表，可能比B+树慢
* hash索引不支持范围查找，不支持排序，不支持复合索引查找

**建表时使用自增的id做为主键**

　　InnoDB中表中的数据是直接存储在主键/聚簇索引的叶子节点中的，这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点） 。如果主键是自增的，只需要把新增的一条记录存储在上一条记录的后面；若表的主键不是自增的，就可以看作是无规律的，需要做排序移动，找一个合适的位置来存储，会导致大量的随机IO操作；同时，频繁的移动和分页会造成大量碎片，使索引结构不够紧凑

**索引优势**

- 提高数据库快速检索的能力，降低了IO成本
- 索引排好序降低了排序成本，降低了CPU消耗

**索引劣势**

- 索引本身也是文件，要占用大量空间
- 当数据更新时，不仅数据要更新，索引也要更新，更新效率变慢
- 创建和维护索引需要耗费时间，且数据量越大时间越多

**需要建索引的情况**

- 主键自动建立唯一非空索引
- 频繁查询的字段需要建索引
- 排序字段可以建索引
- 多表连接，需要外键索引

适合建索引的字段：唯一、非空且经常查询

**不需要建索引的情况**

- 频繁更新的字段不需要索引

- where没使用的字段或很少查询的字段不需要索引

- 记录太少的表不需要索引

- 重复值太多/索引选择性太低的字段不需要索引，比如性别

  *索引的选择性：字段未重复的记录数/字段总记录数*

### 索引在order by的应用

order by用到了索引的排序，没用到检索功能。复合索引在B+树的叶子节点中是将索引中的列按从左到右的顺序依次排序的

order by 排序有两种：index和filesort。filesort有两种排序：单路排序和双路排序

- 双路排序

  扫描两次磁盘

- 单路排序

  扫描一次磁盘，在buffer中进行排序，按排序结果输出，避免二次扫描。但在buffer中排序需要更多空间，如果buffer空间不足，不能够一次取出所有数据就会多次单路排序，反而更耗时

*多列进行order by 时，同为asc或者desc会使用index，否则用filesort*

*group by会先排序*

### 索引优化

MySQL查询性能下降原因

- SQL语句写的不好
- 索引失效，设置了索引但没用上
- 太多join，子查询
- 调优参数设置问题

#### explain

模拟MySQL优化器执行SQL语句的过程，方法是explain+SQL语句

explain的结果（例）

|  id  | select_type |   table    | type  | possible keys |     key      | key_len | ref  | rows | Extra |
| :--: | :---------: | :--------: | :---: | :-----------: | :----------: | :-----: | :--: | :--: | :---: |
|  2   |   simple    |     A      |  ref  | idx_col1col2  | idx_col1col2 |    5    | col1 |  56  |       |
|  1   |   primary   |     B      | range |   idx_col3    |     null     |  null   | col3 | 100  |       |
|  1   |   derived   | derived(2) | const |     null      | idx_col1col2 |    6    | col2 |  1   |       |

explain可以做的事

- 查看表的读取顺序，引用关系

id表示读取表的顺序，有三种情况

|    id    |                           含义                            |
| :------: | :-------------------------------------------------------: |
|  全相同  |             按照table的内容，自上而下顺序读取             |
|  全不同  |              先读取id大的表，id小的最后读取               |
| 不全相同 | 先读取id大的表，对于id相同的表，按照table自上而下顺序执行 |

derived(2)表示该表是从id为2的表读取出来的

- 查询类型

由select_type说明，分为6种

| select_type  |             含义             |
| :----------: | :--------------------------: |
|    simple    |    不包含子查询和连接查询    |
|   primary    | 子查询中最外层的查询或主查询 |
|   subquery   |            子查询            |
|   derived    | 衍生查询，包含在from里的查询 |
|    union     |           连接查询           |
| union result |         union的结果          |

- 表的连接类型（type）

由好到坏：system>const>eq_ref>ref>range>index>all

|  type  |                        含义                        |
| :----: | :------------------------------------------------: |
| system |                  表中只有一行记录                  |
| const  | 有确定的索引，常用于主键或唯一键，最多只有一行记录 |
| eq_ref |        唯一性索引，每一个索引都只有一条记录        |
|  ref   |   非唯一性索引，每一个索引都返回对应的所有的记录   |
| range  | 只检索一定范围的行，一般出现在between，in，>，<等  |
| index  |                全索引扫描，遍历索引                |
|  all   |                      全表扫描                      |

- 查看是否利用索引

possible key是可能用到的索引，key是实际用到的索引，null表示没用索引或者索引失效

- 查看使用的索引字节数

key_len是索引字段的最大可能长度，不是实际长度，索引越多，key_len越大，查找精度相同时，该值越小越好

- 查看使用了索引的哪些列

ref表示，如果是const，那就是查询使用的索引是一个常数；一般格式是database.table.column

- 查看有多少行被优化器查询

rows表示，估算要读取的行数，越小越好

- 其他信息

不适合放在其他列但也很重要，extra表示

|       extra       |                             含义                             |
| :---------------: | :----------------------------------------------------------: |
|  using filesort   | 文件内排序，实际使用的复合索引的列的个数或顺序和复合索引不一致。比如索引idx_A_abc，实际使用的索引列是a和c |
|  using temporary  |               临时表，多见于order by和group by               |
|    using index    | 表明效率不错，若同时存在using where，表明索引被用于查找；若不存在，表明索引只是用来读取数据 |
| using join buffer |                             缓存                             |
| impossible where  |                 where连接条件不可能同时存在                  |

*覆盖索引：查询的字段都包含在索引列（包括primary key）里*

**join连接时的索引优化**

left join时索引建在右表，right join时索引建在左表，尽量使用覆盖索引，不用select *

#### 索引失效原因

- 全值匹配(=)时违反了最佳左前缀原则

*最佳左前缀原则：使用复合索引查找时，必须按照建立索引的列的顺序，从最左边的索引列开始，不能跳过中间列，可以是索引列的子列*

复合索引的存储和最佳左前缀： https://blog.csdn.net/ibigboy/article/details/104571930?depth_1- 

- 查询条件只有or时，前后两个条件都是索引的列会生效
- 在索引列的任何操作（计算，函数，类型转换）
- 复合索引的中间某列explain的type为range(>,<,between and)，后面的索引列都失效
- !=，<>，is null都会使索引失效
- 使用通配符和like查找时，explain的type是range，解决方法是使用覆盖索引，形如`like '%a'`和`like '%a%'`都会使索引失效，但形如`like 'a%'/'a%aa%'`索引不会失效

## 慢查询

记录执行时间超过阈值的SQL语句的日志

开启慢查询：

```sql
set gloable slow_query_long on 

service mysqld restart 
```

慢查询变量：

* slow_query_log： 慢查询开启状态
* slow_query_log_file ：慢查询日志的存放位置
* long_query_time：查询超过多少秒才记录 

## show profile

可以显示所有执行的SQL语句的执行时间

```sql
-- 显示query_id这条SQL语句在整个执行子过程的执行时间，CPU消耗等
show profile cpu,block io for query `query_id`
```

## 查询优化

步骤：

- 在慢查询日志里找到慢查询SQL
- explain执行
- show profile查看执行细节

方法：

* 建索引
* 避免索引失效
* 减少子查询
* 减少表连接
* 减少临时表使用
* 经常查询的字段可以建中间表
* 优化SQL语句
* 减少查询字段
* 少使用游标
* 两表连接时，小表驱动大表来优化查询

in与exists比较

```sql
-- B表小于A表
select * from A where id in (select id from B );
-- A表小于B表，exists返回的是布尔值，子查询中select *会被忽略，可以写select 1/任意值
select * from A where exists (select * from B where A.id=B.id );
```

## 服务器优化

* 优化服务器硬件，如配置更大的内存，配置SSD，配置多核处理器
* SQL参数调优，如key_buffer_size，适当增加索引缓冲区的大小。table_cache，适当增加同时打开表的个数。sort_buffer_size，增加排序缓冲区大小，使排序更快

## 数据库设计优化

* 对大表分库分表
* 批量插入数据代替多次单条插入
* 选择数据类型遵循小而简单的原则，越小的数据类型通常会占用更少的磁盘、内存，处理时需要的CPU周期也更少 
