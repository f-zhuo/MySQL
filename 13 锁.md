# 锁

协调多进程或多线程并发的机制，对于并发，若没有锁，可能会破坏数据一致性（脏读，不可重复读，幻读）

可以分为两类：乐观锁和悲观锁

## 乐观锁

用户自己实现的锁机制，认为事务A执行操作时不会有其他事务修改数据，数据一般不会发生冲突，在对数据提交更新的时候才会检查。一旦发现数据冲突，会返回错误信息，由用户决定如何做。乐观锁一般的实现方式是版本号/时间戳

## 悲观锁

认为事务A执行操作时会有其他事务修改数据，需要加锁，按对数据操作的粒度来分

- 表锁（偏读）
- 行锁（偏写）
- 页锁

### 表锁

#### 读锁

共享锁，事务A读取某一行的数据时，会给这一行加一个锁，其他的事务可以读取该数据但不能访问。当事务A读取完毕后就解除共享锁。并发性好，可同时进行多个读操作；兼容性好，可以放置其他共享锁和更新锁

#### 写锁

又叫排它锁或独占锁，执行写操作（insert，delete，update）时会自动添加，当前写操作没有完成就不允许其他读和写操作，并发性差，其他事务想要操作只能等待；兼容性差，已经有其他锁就不能放置排它锁，有了排它锁也不能放置其他锁

#### 意向锁

首先来看一种情况，事务A对2行进行修改，添加了共享锁，只能访问不能修改；事务B需要对整个表进行修改，在此之前需要判断整个表是否可以修改。分为两步判断：第一步：判断是否有表锁；第二步：遍历整个表的每一行，判断是否有行锁。显然这种遍历的操作效率太低了

为了提高效率，出现了意向锁。意向锁会记录当前事务是否添加了行锁，是在加行锁前申请的。所以上述的第二步就可以改成访问意向锁，提高了效率

所以意向锁的作用在于**判断是否有某个事务正在/将要锁定某一行**

### 行锁

#### 读锁

#### 写锁

#### 更新锁

为了解决行锁的死锁问题而出现的。比如

```mysql
update t1 set name='dahuang' where id=1;
```

执行这个语句分两步，第一步读取id为1的记录，此时使用共享锁；第二步，将这个记录的name改为dahuang，此时使用排它锁。若同时有两个事务对这一数据进行修改，两个事务都施加了共享锁，A要加排它锁时，需要B释放所有锁，B要先加排它锁再释放，但施加排它锁也需要A释放所有锁，这样两个事务出现了竞争，会阻塞出现死锁

更新锁解决了这个问题：更新锁和共享锁是兼容的，执行update时，会先分配一个更新锁，等共享锁释放后，更新锁就变为排它锁。对于同一数据，存在多个事务时，可以存在多个共享锁，但只会有一把更新锁。这样最多只会有一个事务获得排它锁，其他事务只有等该事务完成之后才能获得更新锁，不会出现死锁。更新锁也允许高并发，但只允许多事务锁定，不允许更新

##### 死锁

两个或两个以上的进程竞争资源出现的阻塞情况，若无外力介入将永远无法推进

产生条件：

* 互斥条件：某个资源只能被一个进程占用，其他进程想要获取只能等待释放
* 请求和保持条件：一个进程在占有资源的情况下申请其他资源，该资源已被其他进程占有，并且自身的资源不会释放
* 环路等待条件：存在一个环形的资源链进程，每个进程都在等待前面的进程结束
* 不剥夺条件：进程占用资源只能在使用结束时由自身释放，不能由其他进程剥夺

破坏死锁，破坏其中一个条件即可：

* 破坏互斥性：将需要使用的资源拷贝多个副本，但若资源成本高，进程又多，就不适用了
* 破坏请求和保持条件：规定进程必须释放自身的资源才能请求新资源
* 破坏环路等待条件：规定每个进程获取资源的顺序一致，只能先获取资源1，再获取资源2。。。
* 破坏不可剥夺条件：设置时间阈值，一旦超过这个阈值还在阻塞状态，就释放资源。还可以重启，直接释放资源

**银行家算法**：是一种动态避免进入死锁状态的方法。每次分配资源前都会进行检查，若系统状态安全就分配，否则不分配

```sql
-- 给表添加读锁，写锁
lock table t1 read,t2 write;
-- 查看加锁的表
show open tables;
-- 解锁
unlock tables;

-- 加行锁
begin;
select * from t1 where id=1 for update;
update t1 set xxx where id=1;-- 对该记录修改
commit;
```

user1给表一加了读锁时，user1不能访问/修改其他表，其他user可以访问表一，但修改表一时会被阻塞等待，当user1给表一解锁后就可以修改

user1给表一加了写锁时，user1不能访问/修改其他表，其他user访问/修改表一时会被阻塞等待，当user1给表一解锁后就可以访问/修改

MyISAM只用到了表锁，不会出现死锁的情况，锁的开销小，但并发能力差；InnoDB同时拥有表锁和行锁，锁的开销大，可能出现死锁，但并发能力更好。InnoDB是给索引加锁实现行锁的，所以若不使用索引查询，只会使用表锁

MyISAM在执行查询语句前，会自动给相关的表加上读锁；在执行增删改语句之前，会自动给相应的表加写锁

```sql
-- 查看表锁的情况
show status like 'table%';

/* Table_locks_immediate:表锁次数
   Table_locks_waited：表锁争用等待的次数，值越大说明锁造成的阻塞情况月严重
*/


-- 查看行锁的情况
show status like 'innodb_row_lock%';
/*  innodb_row_lock_wait：行锁争用等待的次数
	innodb_row_lock_time_avg：等待平均时长
	innodb_row_lock_time：等待总时长
*/
```

**页锁**性能介于行锁表锁之间，性能也一般

**间隙锁**：当使用范围查找时，innodb会把满足条件的所有记录加锁，即使该记录不存在，这样如果另一个事务插入该不存在的记录时就会阻塞。如，表A有id为1，3，4，5的四条记录，使用`select * from A where id>1`，那么innodb就会把id大于1的记录全部锁住，包括id=2的，哪怕其不存在。若有另一个事务对id=2的记录做插入`insert A(id) values(2)`，那么这个SQL会阻塞直至前一个提交
