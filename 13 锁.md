# 锁

协调多进程或多线程并发的机制，对于并发，若没有锁，可能会破坏数据一致性（脏读，不可重复读，幻读）

可以分为两类：乐观锁和悲观锁

## 乐观锁

用户自己实现的锁机制，认为多事务并发时，事务A执行操作时不会有其他事务修改数据，数据一般不会发生冲突，在对数据提交的时候才会检查。一旦发现数据冲突，会回滚或者重试。乐观锁一般的实现方式是版本号/时间戳，比较读取的数据和提交的数据版本号是否一致，解决写-写冲突问题

乐观锁是一种并发类型的锁，其本身不对数据进行加锁，支持高并发，各事务能够在不加锁的情况下处理自身的数据，省掉了对数据加锁和解锁的过程，大大的提高了数据操作的性能 。乐观锁响应速度更快，但发生冲突的概率更大

## 悲观锁

认为事务A执行操作时会有其他事务修改数据，需要加锁，在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何事务都不能对该数据进行操作。一般数据库锁的机制都是基于悲观锁实现的，可以保证数据的完整性和一致性，而加锁释放锁的过程会造成消耗，所以性能不高

按对数据操作的粒度来分

- 表锁（偏读）
- 行锁（偏写）
- 页锁

### 表锁

锁的时候锁住整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能进行

特点是： 粒度大，加锁简单，不会出现死锁，但容易冲突，不适合并发

```mysql
-- 分别给表添加读锁，写锁
lock table t1 read,t2 write;
-- 查看加锁的表
show open tables;
-- 解锁
unlock tables;

-- 查看表锁的情况
show status like 'table%';

/* Table_locks_immediate:表锁次数
   Table_locks_waited：表锁争用等待的次数，值越大说明锁造成的阻塞情况越严重
*/
```

### 行锁

锁的时候锁住表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可正常访问

特点是：粒度小，加锁比表锁麻烦，会出现死锁，但不易冲突，并发更高。

Innodb中的锁是作用在索引上面的，当SQL命中索引时，锁住的就是命中条件内的索引节点（行锁），如果没有命中索引的话，那我们锁的就是整个索引树（表锁）。索引失效，行锁会变成表锁（行锁是建在索引上的）

```sql
-- 查看行锁的情况
show status like 'innodb_row_lock%';
/*  innodb_row_lock_wait：行锁争用等待的次数
	innodb_row_lock_time_avg：等待平均时长
	innodb_row_lock_time：等待总时长
*/
```

#### 记录锁

record lock，是一种特殊的行锁，只会锁住某一行记录，条件是精准命中且命中的索引是唯一索引。若表没有索引，会自动创建聚集索引，记录锁依然生效

#### 间隙锁

gap lock，当表的相邻索引之间出现空隙则会形成一个区间，遵循左开右闭原则，在事务加锁后会锁住其中某一个区间，称为间隙锁。 触发条件是使用范围查询并且未命中查询记录，查询条件必须命中索引，间隙锁只会出现在REPEATABLE_READ的事务级别中，和记录锁一起用来解决幻读问题

#### 临键锁

Next-Key Lock，是InnoDB默认的行锁算法，相当于记录锁加上间隙锁。当使用范围查找时，innodb会把满足条件的所有记录加锁，查询范围里的区间也会加锁，与之相邻的下一个区间也会加锁。触发条件是使用范围查询并命中，同时命中了索引

对于间隙锁和临键锁来说，即使某记录不存在，如果另一个事务插入该不存在的记录时就会阻塞。如，表A有id为1，3，4，5的四条记录，使用`select * from A where id>1`，那么innodb默认使用临键锁，就会把id大于1的记录全部锁住，包括id=2的，哪怕其不存在。若有另一个事务对id=2的记录做插入`insert A(id) values(2)`，那么这个SQL会阻塞直至前一个提交

### 页锁

性能介于行锁表锁之间，会出现死锁

按属性分：读锁和写锁

### 读锁

共享锁share lock，简称S锁，事务A读取某一行的数据时，会给这一行加一个锁，其他的事务可以读取该数据但不能访问。当事务A读取完毕后就解除共享锁。并发性好，可同时进行多个读操作；兼容性好，可以放置其他共享锁和更新锁

```mysql
-- 显式地给行加读锁
begin;
select * from t1 where id=1 lock in share mode;
-- 释放锁
commit;/rollback
```

### 写锁

又叫排它锁或独占锁exclusive lock，简称X锁，执行写操作（insert，delete，update）时会自动添加，当前写操作没有完成就不允许其他读和写操作，并发性差，其他事务想要操作只能等待；兼容性差，已经有其他锁就不能放置排它锁，有了排它锁也不能放置其他锁

```mysql
-- 给行加写锁
begin;
select * from t1 where id=1 for update;
update t1 set xxx where id=1;
-- 释放锁
commit;/rollback; 
```

### 意向锁

事务对某个表加排它锁之前，需要先检测这个表是否有表锁或者行锁，因为排它锁不兼容其他锁。对于表锁，检测是很容易的，但是对于行锁，需要遍历每行，显然这种遍历的操作效率太低了

为了提高效率，出现了意向锁（intention lock），分为意向共享锁（IS）和意向排它锁（IX），属于表锁。每个行申请共享锁和排它锁之前都会先加上意向共享锁或者意向排它锁，用来表示某个事务想要给某一行加上X锁或者S锁。这样，某事务想要给表加X锁之前就只需要检测表是否存在X,S,IX,IS锁即可

IS锁和IX锁自身兼容且互相兼容，S锁只兼容IS锁

### 更新锁

为了解决行锁的死锁问题而出现的。比如

```mysql
update t1 set name='dahuang' where id=1;
```

执行这个语句分两步，第一步读取id为1的记录，此时使用共享锁；第二步，将这个记录的name改为dahuang，此时使用排它锁。若同时有两个事务对这一数据进行修改，两个事务都施加了共享锁，A要加排它锁时，需要B释放所有锁，B要先加排它锁再释放，但施加排它锁也需要A释放所有锁，这样两个事务出现了竞争，会阻塞出现死锁

更新锁解决了这个问题：更新锁和共享锁是兼容的，执行update时，会先分配一个更新锁，等共享锁释放后，更新锁就变为排它锁。对于同一数据，存在多个事务时，可以存在多个共享锁，但只会有一把更新锁。这样最多只会有一个事务获得排它锁，其他事务只有等该事务完成之后才能获得更新锁，不会出现死锁。更新锁也允许高并发，但只允许多事务锁定，不允许更新

##### 死锁

两个或两个以上的进程因加锁顺序不一致而竞争资源出现的阻塞情况，若无外力介入将永远无法推进

产生条件：

* 互斥条件：某个资源只能被一个进程占用，其他进程想要获取只能等待释放
* 请求和保持条件：一个进程在占有资源的情况下申请其他资源，该资源已被其他进程占有，并且自身的资源不会释放
* 环路等待条件：存在一个环形的资源链进程，每个进程都在等待前面的进程结束
* 不剥夺条件：进程占用资源只能在使用结束时由自身释放，不能由其他进程剥夺

破坏死锁，破坏其中一个条件即可：

* 破坏互斥性：将需要使用的资源拷贝多个副本，但若资源成本高，进程又多，就不适用了
* 破坏请求和保持条件：规定进程必须释放自身的资源才能请求新资源
* 破坏环路等待条件：规定每个进程获取资源的顺序一致，只能先获取资源1，再获取资源2。。。
* 破坏不可剥夺条件：设置时间阈值，一旦超过这个阈值还在阻塞状态，就释放资源。还可以重启，直接释放资源

**银行家算法**：是一种动态避免进入死锁状态的方法。每次分配资源前都会进行检查，若系统状态安全就分配，否则不分配

MyISAM只用到了表锁，不会出现死锁的情况，锁的开销小，但并发能力差；InnoDB同时拥有表锁和行锁，锁的开销大，可能出现死锁，但并发能力更好。InnoDB是给索引加锁实现行锁的，所以若不使用索引查询，只会使用表锁

MyISAM在执行查询语句前，会自动给相关的表加上读锁；在执行增删改语句之前，会自动给相应的表加写锁

## 封锁协议

在运用X锁和S锁这两种基本封锁对数据对象加锁时，还需要约定一些规则。例如，何时申请X锁或S锁、封锁时间、何时释放等。这些规则称为封锁协议，目的是保证数据的一致性

### 一级封锁协议

事务在修改数据前加X锁，在事务完成后释放，可以解决更新丢失的问题

### 二级封锁协议

在一级封锁协议的基础上，事务读取数据时加S锁，读取结束后立即释放，可以解决更新丢失，脏读的问题

### 三级封锁协议

在二级封锁协议的基础上，事务读数据前加S锁，事务完成后释放，可以解决更新丢失，脏读，不可重复读的问题

## 两阶段锁协议

2PL，主要用于单机事务。加锁一定发生在解锁之前，事务加锁和解锁的阶段是严格区分的，一个事务一旦释放锁就不能申请新锁，多个锁的释放是同时进行的（commit/rollback）。目的是保证并行的准确度，使得并行的结果和串行化一致。事务遵循两段锁协议就一定可以串行化调度，但串行化调度未必遵守两段锁协议

*S2PL（strict-2PL）：规定事务中只有commit和roll back才会释放锁，其余时间都为加锁*

如：一个事务有A,B,C三个部分

两段锁：

`lock(A),lock(B),lock(C),unlock(A),unlock(B),unlock(C)`

非两段锁：

``lock(A),unlock(A),lock(B),unlock(B),unlock(C),lock(C)``

## MySQL的显示锁定和隐式锁定

InnoDB默认使用两段锁协议，根据隔离级别自动加锁，在commit或rollback时统一释放所有锁，称为隐式锁定

可以使用下列语句显示锁定

```mysql
select ... lock in share mode; -- 给读取的每一行加读锁
select ... for update; -- 给读取的每一行加写锁
```
