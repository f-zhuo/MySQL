## 锁

协调多进程或多线程并发的机制

按对数据操作的类型来分

- 读锁（共享锁）

  可同时进行多个读操作

- 写锁（排它锁）

  当前写操作没有完成就不允许其他读和写操作

按对数据操作的粒度来分

- 表锁（偏读）
- 行锁（偏写）

```sql
-- 给表添加读锁，写锁
lock table t1 read,t2 write;
-- 查看加锁的表
show open tables;
-- 解锁
unlock tables;

-- 加行锁
begin;
select * from t1 where id=1 for update;
update t1 set xxx where id=1;-- 对该记录修改
commit;
```

user1给表一加了读锁时，user1不能访问/修改其他表，其他user可以访问表一，但修改表一时会被阻塞等待，当user1给表一解锁后就可以修改

user1给表一加了写锁时，user1不能访问/修改其他表，其他user访问/修改表一时会被阻塞等待，当user1给表一解锁后就可以访问/修改

MyISAM在执行查询语句前，会自动给相关的表加上读锁；在执行增删改语句之前，会自动给相应的表加写锁

```sql
-- 查看表锁的情况
show status like 'table%';

/* Table_locks_immediate:表锁次数
   Table_locks_waited：表锁争用等待的次数，值越大说明锁造成的阻塞情况月严重
*/


-- 查看行锁的情况
show status like 'innodb_row_lock%';
/*  innodb_row_lock_wait：行锁争用等待的次数
	innodb_row_lock_time_avg：等待平均时长
	innodb_row_lock_time：等待总时长
*/
```

**页锁**性能介于行锁表锁之间，性能也一般

**间隙锁**：当使用范围查找时，innodb会把满足条件的所有记录加锁，即使该记录不存在，这样如果另一个事务插入该不存在的记录时就会阻塞。如，表A有id为1，3，4，5的四条记录，使用`select * from A where id>1`，那么innodb就会把id大于1的记录全部锁住，包括id=2的，哪怕其不存在。若有另一个事务对id=2的记录做插入`insert A(id) values(2)`，那么这个SQL会阻塞直至前一个提交

